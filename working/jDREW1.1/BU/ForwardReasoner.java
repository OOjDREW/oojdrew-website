
package jDREW.BU;

import java.io.*;
import java.util.*;
import java.lang.*;
import jDREW.TEST.*;
import jDREW.util.*;
/**
############################################################################# <br>
#          National Research Council -- IIT - e-Business Fredericton <br>
# <br>
# PROJECT:      jDREW <br>
# AUTHOR(S):    Bruce Spencer <br>
# DATE CREATED: Jun 04 2002 <br>
# LAST MOD:      <br>
# LAST MOD BY:   <br>
# COPYRIGHT:    NRC <br>
# USAGE:        Open source code <br>
# COMMENTS:     none <br>
# VERSION:      1.1  <br>
# <br>
############################################################################# <br>

   <code>BUDCTree</code> is a program to create DefiniteClause facts bottom up.

     
*/
public class ForwardReasoner{

  
   /**
     The variable <code>symbolTable</code> refers to the
     {@link SymbolTable} that receives symbols of {@link jDREW.util.DefiniteClause DefiniteClauses} parsed by {@link jDREW.util.DCFileParser DCFileParser}.*/
  static public SymbolTable symbolTable = new SymbolTable();
  /**
   * A <code> DiscTree </code> variable stores the old facts.
   */
  static public DiscTree oldFactDiscTree = new DiscTree(symbolTable);
  /**
   * A <code> DiscTree </code> variable stores the new rules.
   */
  static public DiscTree newRuleDiscTree = new DiscTree(symbolTable);
  /**
   * A <code> Heap </code> variable stores the new facts.
   */
  static public Heap newFactHeap = new Heap();
  /**
   *  A temporary <code> Vector </code> variable that holds the new rules and the new facts which will be later dispatched to the {@link #newRuleDiscTree} and {@link #newFactHeap}.
   *  
   */
  static public Vector newResults = new Vector();
  /**
   * A flag controling the amount of the debuging messages appeared in the console window.
   */
  static final boolean TRACE = true;

  public static void main(String args[]) throws org.jdom.JDOMException{


//      DCFileParser dcfp = new DCFileParser(symbolTable);
//      dcfp.parseDCFile("test-subsume.dc");
//      loadDefiniteClauses(dcfp.iterator());


//      RuleMLFileParser rfp = new RuleMLFileParser(symbolTable);
//      rfp.parseRuleMLFile("exam.ruleml");
//      loadDefiniteClauses(rfp.iterator());
    
     
    DCFileParser dcfp = new DCFileParser(symbolTable);
    dcfp.parseDCFile(EnvTool.localPath+"BU//examples.dc");
    loadDefiniteClauses(dcfp.iterator());


    if(TRACE){
      System.out.println("Old Facts:\n" + oldFactDiscTree + "\n");
      System.out.println("New Rules:\n" + newRuleDiscTree + "\n");
      System.out.println("New Facts:" + newFactHeap + "\n");
    }

    runForwardReasoner();

    if(TRACE){
      System.out.println("Final Old Facts\n" + oldFactDiscTree);
    }

    System.out.println("All Known Facts");
    Iterator lit = oldFactDiscTree.allLeavesIterator();
    int j = 0;
    while(lit.hasNext()){
      j++;
      System.out.println(j+": " + ((DefiniteClause) lit.next()) );
    }
  }
 /**
  * <code> runForwardReasoner</code> starts the forward reasoning operations on the member variables - e.g. {@link #newFactHeap} and {@link #newRuleDiscTree} - of the <code>ForwardReasoner<code> class.
  */
  public static void runForwardReasoner(){

    while(true){
      if(newFactHeap.isEmpty()) return;

      DefiniteClause newFact =
	(DefiniteClause) newFactHeap.removeSmallest();

      if(forwardSubsumes(oldFactDiscTree, newFact)){
  	if(TRACE){
  	  System.out.println("newFact " + newFact +
  			     " was forward subsumed");
  	}
      }
      else {
	if(TRACE){
	  System.out.println("Selected newFact " + newFact);
	}

	DiscTree.UnifiableIterator uif =
	  newRuleDiscTree.unifiableIterator(newFact,0);

	while(uif.hasNext()){
	  DefiniteClause newRule = (DefiniteClause) uif.next();
	  Unifier u = new Unifier(newRule, newFact);
	  if(u.unified){
	    DefiniteClause newResult = u.resolvent();
	    if(TRACE){
	      System.out.println("new resolvent " + newResult);
	    }
	    newResults.add(newResult);
	  }
	}
	Iterator newResultIt = newResults.iterator();
	while(newResultIt.hasNext()){
	  process((DefiniteClause) newResultIt.next());
	}
	newResults = new Vector();
	oldFactDiscTree.insert(newFact, 0);
      }
    }
  }
/**
 * A recursively called function to ensure that each newly generated fact is put into the {@link #newFactHeap} and each newly generated rule's first premise is tried by all the old facts in the {@link #oldFactDiscTree} and be put into the {@link #newRuleDiscTree}.  
 * The newly generated rules and facts are composed of input DefiniteClause parameter - <cold>result</cold> and all the facts and rules generated by the <code> process </code> function itself.
 * @param result - the DefiniteClause being processed.
 */
  public static void process(DefiniteClause result){

    if(result.symbols.length == result.symbols[0][1]){
      //if result is a fact
      newFactHeap.add(result);
    }
    else {
      DiscTree.UnifiableIterator uif =
  	oldFactDiscTree.unifiableIterator(result, 1);
      while(uif.hasNext()){
  	DefiniteClause oldFact = (DefiniteClause) uif.next();
  	Unifier u = new Unifier(result, oldFact);
  	if(u.unified){
  	  DefiniteClause newResult = u.resolvent();
	  if(TRACE){
	    System.out.println("new resolvent " + newResult);
	  }
  	  process(newResult);
  	}
      }
      newRuleDiscTree.insert(result,1);
    }
  }
	/**
     Load the DefiniteClauses into the {@link #newRuleDiscTree} if they are rules or {@link #newFactHeap} if they are facts. 
     For DefiniteClauses that are rules, they are inserted into the {@link #newRuleDiscTree} using the first premise as the index. 
     For example, rule a(X):-b(X),c(X). will be inserted using b(X) as the index.
  	*/
  public static void loadDefiniteClauses(Iterator it){
    while(it.hasNext()){
      DefiniteClause dc = (DefiniteClause) it.next();
      if(dc.symbols.length == dc.symbols[0][1]){
	//then this definite clause is a fact
	//so put it in with the facts
	newFactHeap.add(dc);
      }
      else{
	//else it is a new rule
	newRuleDiscTree.insert(dc, 1);
      }
    }
  }

/**
 *  Tells if the <code>newFact</code> is subsumed by the old facts.
 * @param oldFactDiscTree - a <code> DiscTree </code> variable that stores the old facts.
 * @param newFact - a <code> DefiniteClause</code> variable which is the new fact.
 * @return true if the old facts subsume the new fact. 
 */
  public static boolean  forwardSubsumes
    (DiscTree oldFactDiscTree, DefiniteClause newFact){
    Unifier u1 = new Unifier(newFact, Unifier.GROUNDING_MODE);
    DiscTree.UnifiableIterator uif =
      oldFactDiscTree.unifiableIterator(newFact, 0);
    while(uif.hasNext()){
      DefiniteClause oldFact = (DefiniteClause) uif.next();
      Unifier u2 = new Unifier(oldFact,0,0,u1,Unifier.ONEWAY_MODE);
      if(u2.unified){
	if(TRACE){
	  System.out.println
	    ("new fact " + newFact +
	     " subsumed by old Fact " + oldFact);
	}
	return true;
      }
    }
    return false;
  }
}






