// OO jDREW Version 0.89
// Copyright (c) 2005 Marcel Ball
//
// This software is licensed under the LGPL (LESSER GENERAL PUBLIC LICENSE) License.
// Please see "license.txt" in the root directory of this software package for more details.
//
// Disclaimer: Please see disclaimer.txt in the root directory of this package.

package jdrew.oo.gui;

import java.util.*;

import javax.swing.*;
import java.awt.*;

import jdrew.oo.bu.*;
import jdrew.oo.util.*;
import nu.xom.*;
import org.apache.log4j.*;

/**
 * This class implements a GUI front-end for the OO jDREW Bottom up module.
 * This gui is ment for demonstration purposes only; but it's code can be used
 * as an example of how to integrate a Bottom-Up engine into a Java application.
 *
 * <p>Title: OO jDREW</p>
 *
 * <p>Description: Reasoning Engine for the Semantic Web - Supporting OO RuleML
 * 0.88</p>
 *
 * <p>Copyright: Copyright (c) 2005</p>
 *
 * @author Marcel A. Ball
 * @version 0.89
 */

public class BottomUpGUI extends javax.swing.JFrame {

    ForwardReasoner fr;
    
    int posl = 0;
   
    public static int currentParser = RuleMLParser.RULEML88;

    Logger logger = Logger.getLogger("jdrew.oo.gui.BottomUpGUI");

    /** Creates new form BottomUpGUI */
    public BottomUpGUI() {
        initComponents();
        fr = new ForwardReasoner();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {
        formatBG = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        typedeftab = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        typetext = new javax.swing.JTextArea();
        parseTypeBtn = new javax.swing.JButton();
        kbtab = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        kbtext = new javax.swing.JTextArea();
        parseKBBtn = new javax.swing.JButton();
        outtab = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        outputtext = new javax.swing.JTextArea();
        runBtn = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jrbPOSL = new javax.swing.JRadioButton();
        jrbRML = new javax.swing.JRadioButton();
        jrbRML91 = new javax.swing.JRadioButton();
        jrbRULE = new javax.swing.JCheckBox();
        jrbOLDNEW = new javax.swing.JCheckBox();
        jrbCHECK = new javax.swing.JCheckBox();
        showdbgBtn = new javax.swing.JButton();
        inputLoopCounter = new javax.swing.JTextField();
        
        dbgcon = new DebugConsole();

        getContentPane().setLayout(null);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("OO jDREW Bottom Up");
        getAccessibleContext().setAccessibleName("OO jDREW Bottom-Up Engine");
        typedeftab.setLayout(null);

        jScrollPane1.setViewportView(typetext);

        typedeftab.add(jScrollPane1);
        jScrollPane1.setBounds(12, 10, 760, 510);

        parseTypeBtn.setText("Parse Type Information");
        parseTypeBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                parseTypeBtnActionPerformed(evt);
            }
        });
		
        typedeftab.add(parseTypeBtn);
        parseTypeBtn.setBounds(591, 530, 180, 23);

        jTabbedPane1.addTab("Type Definitions", typedeftab);

        kbtab.setLayout(null);

        jScrollPane2.setViewportView(kbtext);

        kbtab.add(jScrollPane2);
        jScrollPane2.setBounds(12, 10, 760, 510);

        parseKBBtn.setText("Parse Knowledge Base");
        parseKBBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                parseKBBtnActionPerformed(evt);
            }
        });

        kbtab.add(parseKBBtn);
        parseKBBtn.setBounds(591, 530, 180, 23);

        jTabbedPane1.addTab("Knowledge Base", kbtab);

        outtab.setLayout(null);

        jScrollPane3.setViewportView(outputtext);

        outtab.add(jScrollPane3);
        jScrollPane3.setBounds(12, 10, 760, 510);

        runBtn.setText("Run Forward Reasoner");
        runBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runBtnActionPerformed(evt);
            }
        });

        outtab.add(runBtn);
        runBtn.setBounds(591, 530, 180, 23);

        jTabbedPane1.addTab("Output", outtab);

        getContentPane().add(jTabbedPane1);
        jTabbedPane1.setBounds(10, 10, 790, 590);

		jLabel1.setText("Input/Output Format:");
        getContentPane().add(jLabel1);
        jLabel1.setBounds(20, 610, 130, 20);

        jLabel2.setText("Set Loop Counter:");
        getContentPane().add(jLabel2);
        jLabel2.setBounds(20, 635, 200, 20);
        
        inputLoopCounter.setText("0");
        getContentPane().add(inputLoopCounter);
	    inputLoopCounter.setBounds(150, 635, 100, 20);
	    
	    jrbRULE.setText("Print Rules");
        getContentPane().add(jrbRULE);
        jrbRULE.setBounds(420, 610, 190, 23);
	    
	    jrbCHECK.setText("Test for Stratification");
	    getContentPane().add(jrbCHECK);
	    jrbCHECK.setBounds(420,635,190,23);

        jrbOLDNEW.setText("Seperate Facts");
		getContentPane().add(jrbOLDNEW);
		jrbOLDNEW.setBounds(420, 660, 190, 23);
		
        formatBG.add(jrbPOSL);
        jrbPOSL.setSelected(true);
        jrbPOSL.setText("POSL");
        getContentPane().add(jrbPOSL);
        jrbPOSL.setBounds(160, 610, 110, 23);

        formatBG.add(jrbRML);
        jrbRML.setText("RuleML 0.88+");
        getContentPane().add(jrbRML);
        jrbRML.setBounds(270, 610, 150, 23);
        
        formatBG.add(jrbRML91);
        jrbRML91.setText("RuleML 0.91");
        getContentPane().add(jrbRML91);
        jrbRML91.setBounds(270, 635, 110, 23);

        showdbgBtn.setText("Show Debug Console");
        showdbgBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showdbgBtnActionPerformed(evt);
            }
        });

        getContentPane().add(showdbgBtn);
        showdbgBtn.setBounds(621, 610, 180, 23);

        pack();

        this.setBounds(0, 0, 810, 700);
        this.setResizable(false);
    }

    /**
     * This method is used to run the engine. This is done by calling the
     * runForwardReasoner() method of the ForwardReasoner object, this should
     * only be done after loading type information (using an RDFSParser) and
     * parsing (using POSLParser or RuleMLParser) and loading the knowledge
     * base using the loadClauses(Iterator clauses) method of the
     * ForwardReasoner object.
     */
    private void runBtnActionPerformed(java.awt.event.ActionEvent evt) {
      
           try {
                fr.setLoopCounter(inputLoopCounter.getText());
            } catch (Exception ex1) {
                this.logger.error(ex1.getMessage(), ex1);
                JOptionPane.showMessageDialog(this, ex1.getMessage(), "Invalid Number Input",
                                              JOptionPane.ERROR_MESSAGE);
            return;
            }
      
 		fr.printClauses(0);
 		
        //check the forward reasoner class now
        
        fr.runForwardReasoner();
		
        System.err.println("Ran Reasoner");

        Hashtable oldFacts = fr.getOldFacts();

        if(oldFacts.containsKey(new Integer(SymbolTable.IINCONSISTENT))){
            Vector v = (Vector)oldFacts.get(new Integer(SymbolTable.IINCONSISTENT));
            if(v.size() > 0){
                logger.warn("Knowledge base is inconsistent.");
                JOptionPane.showMessageDialog(this, "Knowledge base is inconsistent", "Consistency Check", JOptionPane.WARNING_MESSAGE);
            }
        }
		

        Hashtable rules = fr.getRules();
        Enumeration e1 = oldFacts.elements();
        
       if(this.jrbOLDNEW.isSelected()){
        	StringBuffer sb = new StringBuffer(4096);
        	
        	if(this.jrbPOSL.isSelected()){
        		String poslFacts = fr.printClauses(posl);
        		sb.append(poslFacts);

        		if(jrbRULE.isSelected()){
            
           		  sb.append("\n% Rules : \n");
           		  e1 = rules.elements();
          			  while (e1.hasMoreElements()) {
            		    Vector rulesv = (Vector) e1.nextElement();
            		    Iterator it = rulesv.iterator();
             			   while (it.hasNext()) {
               				     DefiniteClause dc = (DefiniteClause) it.next();
                  				 sb.append(dc.toPOSLString() + "\n");
               		 		}						
            			}		
           		}
	    		this.outputtext.setText(sb.toString()); 
        	}
        	
        	else{
        		String ruleMLFacts = "";
        		//Can add here to change the current parser so that
        		//you can exchange between ruleml 0.88 and 0.91
        		if(this.jrbRML91.isSelected()){
        			
        			currentParser = RuleMLParser.RULEML91;
        			ruleMLFacts = fr.printClauses(RuleMLParser.RULEML91);
        		}
        		if(this.jrbRML.isSelected()){
        			
        			currentParser = RuleMLParser.RULEML88;
        			ruleMLFacts = fr.printClauses(RuleMLParser.RULEML88);
        		}   
        		     			
        		
        		sb.append(ruleMLFacts);

        		  if(jrbRULE.isSelected()){
            
           		  sb.append("\n% Rules : \n");
           		  e1 = rules.elements();
          			  while (e1.hasMoreElements()) {
            		    Vector rulesv = (Vector) e1.nextElement();
            		    Iterator it = rulesv.iterator();
             			   while (it.hasNext()) {
               				     DefiniteClause dc = (DefiniteClause) it.next();
                  				 sb.append(dc.toRuleMLString() + "\n");
               		 		}						
            			}		
           		}
        		
        		this.outputtext.setText(sb.toString());
        	}
        
        	return;
        }
        
          if (this.jrbPOSL.isSelected()) {
        	       	
            StringBuffer sb = new StringBuffer(4096);
            
            sb.append("% Processed Facts:\n\n");
            Enumeration e = oldFacts.elements();
            while (e.hasMoreElements()) {
               Vector facts = (Vector) e.nextElement();
               Iterator it = facts.iterator();
                while (it.hasNext()) {
                    DefiniteClause dc = (DefiniteClause) it.next();
                   sb.append(dc.toPOSLString() + "\n");    
              }
            
            }
            //Add the option to print rules or not
            if(jrbRULE.isSelected()){
            
            sb.append("\n% Rules : \n");
            e = rules.elements();
            while (e.hasMoreElements()) {
                Vector rulesv = (Vector) e.nextElement();
                Iterator it = rulesv.iterator();
                while (it.hasNext()) {
                    DefiniteClause dc = (DefiniteClause) it.next();
                    sb.append(dc.toPOSLString() + "\n");
                }
            }
           }
           
            this.outputtext.setText(sb.toString());
        } 
        
        else  {
        	
        	//Can add here to change the current parser so that
        	//you can exchange between ruleml 0.88 and 0.91
        	    if(this.jrbRML91.isSelected()){
        	
        			currentParser = RuleMLParser.RULEML91;
        		}
        		if(this.jrbRML.isSelected()){
        	
        			currentParser = RuleMLParser.RULEML88;
        		} 
        	//this displays the ruleml stuff
        	//I need to find out why slots arnt working right with data
        	
            Element el = new Element("Assert");
            Element and = new Element("And");
            el.appendChild(and);
            Enumeration e = oldFacts.elements();
            while (e.hasMoreElements()) {
            	//check for when slot gets printing and maybe I cna do some
            	//manipulation somehow
                Vector facts = (Vector) e.nextElement();
                Iterator it = facts.iterator();
                while (it.hasNext()) {
                    DefiniteClause dc = (DefiniteClause) it.next();
                                 
                    if(dc.atoms[0].symbol == SymbolTable.IINCONSISTENT)
                        continue;
                        and.appendChild(dc.toRuleML());
                }
            }
            //Add the option to print rules or not
            if(jrbRULE.isSelected()){
            
            e = rules.elements();
            while (e.hasMoreElements()) {
                Vector rulesv = (Vector) e.nextElement();
                Iterator it = rulesv.iterator();
                while (it.hasNext()) {
                    DefiniteClause dc = (DefiniteClause) it.next();                  
                    if(dc.atoms[0].symbol == SymbolTable.IINCONSISTENT)
                        continue;
                    and.appendChild(dc.toRuleML());
                }
              }
			}
            java.io.StringWriter sw = new java.io.StringWriter();
            nu.xom.Serializer sl = new nu.xom.Serializer(sw);
            sl.setIndent(3);
            sl.setLineSeparator("\n");
            try {
                sl.write(el);
            } catch (java.io.IOException ex) {
                this.logger.error(ex.getMessage(), ex);
                JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                              JOptionPane.ERROR_MESSAGE);
            }

            this.outputtext.setText(sw.getBuffer().toString());
        }
    }

    /**
     * This method implements a knowledge base parsing routine.
     *
     * The first step is to reset the symbol table (call the static reset()
     * method of the SymbolTable class) and create a new ForwardReasoner
     * object.
     *
     * Then the knowledge base and the format of the knowledge base are
     * retrieved from the user interface; once this is done an appropriate
     * parser is created and the knowledge base is parse (using the
     * parseDefiniteClauses(String) method of the POSLParser class or the
     * parseRuleMLString(int FORMAT, String) method of the RuleMLParser class).
     *
     * Once the knowledge base is parsed an iterator over the parsed clauses is
     * created using the iterator() method of the RuleMLParser or POSLParser
     * class; this Iterator is then passed to the loadClauses(Iterator) method
     * of the ForwardReasoner object.
     *
     * It also checks to see if the knowledgebase is stratifiable.
     */
    private void parseKBBtnActionPerformed(java.awt.event.ActionEvent evt) {
           try {
                fr.setLoopCounter(inputLoopCounter.getText());
            } catch (Exception ex1) {
                this.logger.error(ex1.getMessage(), ex1);
                JOptionPane.showMessageDialog(this, ex1.getMessage(), "Invalid Number Input",
                                              JOptionPane.ERROR_MESSAGE);
            return;
            }
      
        logger.debug("Parsing Knowledge Base");
        String kbstr = this.kbtext.getText();

        SymbolTable.reset();
        fr = new ForwardReasoner();

        if (kbstr.trim().equals("")) {
            return;
        }

        if (this.jrbPOSL.isSelected()) {
            POSLParser pp = new POSLParser();
            try {
                pp.parseDefiniteClauses(kbstr);
            } catch (Exception ex1) {
                this.logger.error(ex1.getMessage(), ex1);
                JOptionPane.showMessageDialog(this, ex1.getMessage(), "Error",
                                              JOptionPane.ERROR_MESSAGE);
            }

            fr.loadClauses(pp.iterator());
        } //ruleml 0.88
         if (this.jrbRML.isSelected()) {
         	
            currentParser = RuleMLParser.RULEML88;
            
            RuleMLParser rmp = new RuleMLParser();
            try {
                rmp.parseRuleMLString(RuleMLParser.RULEML88, kbstr);
            } catch (Exception ex) {
                this.logger.error(ex.getMessage(), ex);
                JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                              JOptionPane.ERROR_MESSAGE);
            }

			Iterator it = rmp.iterator();

            fr.loadClauses(rmp.iterator());
          //ruleml 0.91
        }else if(this.jrbRML91.isSelected()){
        	
        	currentParser = RuleMLParser.RULEML91;
        	
        	RuleMLParser rmp = new RuleMLParser();
            try {
                rmp.parseRuleMLString(RuleMLParser.RULEML91, kbstr);
            } catch (Exception ex) {
                this.logger.error(ex.getMessage(), ex);
                JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                              JOptionPane.ERROR_MESSAGE);
            }

			Iterator it = rmp.iterator();

            fr.loadClauses(rmp.iterator());
        	
        }
		//Testing for stratification if user wants to.
		if(jrbCHECK.isSelected()){
				
    		boolean strat = fr.isStratifiable();
    		System.out.println("Is stratifiable: " + strat);
    		//data base is not stratifiable
    		if(!strat){
    			//allowing the user to see the details on why stratification failed
    			int ans = JOptionPane.showConfirmDialog(this, "Knowledge base is not stratifiable. \nWould you like to see more detials?\n", "Non-Stratfiable",
                                	             JOptionPane.YES_NO_OPTION);
    			//if the user wants to see the details they can
    			if(ans == 0){
    				Vector msg = fr.getMessage();
    				Iterator msgIterator = msg.iterator();
    				String message = "";
    				int count = 1;
    				while(msgIterator.hasNext()){
    			
    					message = message + count + ")" + (String)msgIterator.next() + "\n";	
    					count++;
    				}
    				JOptionPane.showMessageDialog(this, message, "Stratification Violations",
                                	             JOptionPane.INFORMATION_MESSAGE);	
    				
    			}
    			
    		}
    		//just tell the user the knowledge base is stratifiable
    		if(strat){
    					JOptionPane.showMessageDialog(this, "Knowledge base is stratifiable.", "Stratfiable",
                                	             JOptionPane.INFORMATION_MESSAGE);
    		}
    	}
    }

    private void showdbgBtnActionPerformed(java.awt.event.ActionEvent evt) {
        this.dbgcon.setVisible(true);
    }

    /**
     * This method is used to load type information into the term typing
     * system.
     *
     * The first thing that is done is that the type input is retrieved from
     * the user interface, then the type system is reset. Once this is done
     * the static parseRDFSString(String) method of the RDFSParser class is
     * called to parse and load the type information.
     *
     * Since any previously parsed clauses that used types are no longer valid
     * (the types system was reset), the knowledge base is reset by calling
     * the parseKBBtnActionPerformed(ActionEvent) method of the GUI.
     */
    private void parseTypeBtnActionPerformed(java.awt.event.ActionEvent evt) {
          try {
                fr.setLoopCounter(inputLoopCounter.getText());
            } catch (Exception ex1) {
                this.logger.error(ex1.getMessage(), ex1);
                JOptionPane.showMessageDialog(this, ex1.getMessage(), "Invalid Number Input",
                                              JOptionPane.ERROR_MESSAGE);
            	return;
            }
        
        String typestr = this.typetext.getText();
        Types.reset();

        logger.debug("Parsing Datatypes.");
        try {
            RDFSParser.parseRDFSString(typestr);
        } catch (Exception ex) {
            this.logger.error(ex.getMessage(), ex);
            JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                          JOptionPane.ERROR_MESSAGE);
        }

        logger.debug("Datatypes updated - must reparse clauses.");


        parseKBBtnActionPerformed(evt);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    javax.swing.UIManager.setLookAndFeel(
                            javax.swing.UIManager.
                            getCrossPlatformLookAndFeelClassName());
                } catch (Exception e) {}

                BasicConfigurator.configure();
                Logger root = Logger.getRootLogger();
                root.setLevel(Level.DEBUG);

                BottomUpGUI frame = new BottomUpGUI();
                frame.setSize(800,750);
                TextPaneAppender tpa = new TextPaneAppender(new PatternLayout(
                        "%-5p %d [%t]:  %m%n"), "Debug");
                tpa.setTextPane(frame.dbgcon.getTextPane());

                root.addAppender(tpa);
                Enumeration e = root.getAllAppenders();
                while (e.hasMoreElements()) {
                    System.out.println(e.nextElement());
                }

                jdrew.oo.Config.PRINTGENOIDS = false;
				frame.setResizable(true);
                frame.setVisible(true);

            }
        });
    }

    // Variables declaration - do not modify
    private javax.swing.ButtonGroup formatBG;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JRadioButton jrbPOSL;
    private javax.swing.JRadioButton jrbRML;
    private javax.swing.JRadioButton jrbRML91;
    private javax.swing.JCheckBox jrbRULE;
    private javax.swing.JCheckBox jrbCHECK;
    private javax.swing.JCheckBox jrbOLDNEW;
    private javax.swing.JPanel kbtab;
    private javax.swing.JTextArea kbtext;
    private javax.swing.JTextArea outputtext;
    private javax.swing.JPanel outtab;
    private javax.swing.JButton parseKBBtn;
    private javax.swing.JButton parseTypeBtn;
    private javax.swing.JButton runBtn;
    private javax.swing.JButton showdbgBtn;
    private javax.swing.JPanel typedeftab;
    private javax.swing.JTextArea typetext;
    private javax.swing.JTextField inputLoopCounter;
    private DebugConsole dbgcon;
    // End of variables declaration

}
