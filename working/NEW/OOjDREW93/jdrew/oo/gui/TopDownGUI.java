// OO jDREW Version 0.89
// Copyright (c) 2005 Marcel Ball
// This is the right one.
// This software is licensed under the LGPL (LESSER GENERAL PUBLIC LICENSE) License.
// Please see "license.txt" in the root directory of this software package for more details.
//
// Disclaimer: Please see disclaimer.txt in the root directory of this package.

package jdrew.oo.gui;

/*
 * TopDownGUI.java
 *
 * Created on March 3, 2005, 2:57 PM
 */

import java.util.*;
import java.io.*;
import javax.swing.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import jdrew.oo.td.*;
import jdrew.oo.util.*;
import org.apache.log4j.*;

/**
 * This class implements a GUI front-end for the OO jDREW Top down module.
 * This gui is ment for demonstration purposes only; but it's code can be used
 * as an example of how to integrate a Top-Down engine into a Java application.
 *
 * <p>Title: OO jDREW</p>
 *
 * <p>Description: Reasoning Engine for the Semantic Web - Supporting OO RuleML
 * 0.88</p>
 *
 * <p>Copyright: Copyright (c) 2005</p>
 *
 * @author Marcel A. Ball
 * @version 0.89
 */
 
public class TopDownGUI extends javax.swing.JFrame {

	public static int currentParser = RuleMLParser.RULEML88;

    BackwardReasoner br;
    Iterator solit;
    Logger logger = Logger.getLogger("jdrew.oo.gui.TopDownGUI");
    /** Creates new form TopDownGUI */
    public TopDownGUI() {
        initComponents();
        br = new BackwardReasoner();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
     
    private void initComponents() {
    	
        JMenu fileMenu = new JMenu("File");
        //creating a ExitAction and a ConnAction both are defined later
        ExitActionTD exitAction = new ExitActionTD("Exit");
        OpenActionTD openAction = new OpenActionTD("Open File");
    
        //adding the connection action and exit action to the menu
        fileMenu.add(openAction);
        fileMenu.addSeparator();            
        fileMenu.add(exitAction);
                
        //making a new menu bar and adding the file menu to it                
        JMenuBar sysMenu = new JMenuBar();
        sysMenu.add(fileMenu);
        setJMenuBar(sysMenu);

        buttonGroup1 = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        tdtab = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        typedeftext = new javax.swing.JTextArea();
        parseTypeBtn = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        kbtab = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        kbtext = new javax.swing.JTextArea();
        parseKBBtn = new javax.swing.JButton();
        jrbPOSL = new javax.swing.JRadioButton();
        jrbRML = new javax.swing.JRadioButton();
        jrbRML91 = new javax.swing.JRadioButton();
        jLabel2 = new javax.swing.JLabel();
        qtab = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        solTree = new javax.swing.JTree();
        queryBtn = new javax.swing.JButton();
        nextBtn = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        varBindTbl = new javax.swing.JTable();
        jScrollPane5 = new javax.swing.JScrollPane();
        querytext = new javax.swing.JTextArea();
        showDbgBtn = new javax.swing.JButton();

        getContentPane().setLayout(null);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("OO jDREW Top-Down Engine");
        tdtab.setLayout(null);

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.
                                                  HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane1.setViewportView(typedeftext);

        tdtab.add(jScrollPane1);
        jScrollPane1.setBounds(10, 10, 760, 510);

        parseTypeBtn.setText("Load Type Information");
        parseTypeBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                parseTypeBtnActionPerformed(evt);
            }
        });

        tdtab.add(parseTypeBtn);
        parseTypeBtn.setBounds(589, 530, 180, 23);

        jLabel1.setText("Input Format: RDFS");
        tdtab.add(jLabel1);
        jLabel1.setBounds(10, 530, 260, 20);

        jTabbedPane1.addTab("Type Definition", tdtab);

        kbtab.setLayout(null);

        jScrollPane2.setViewportView(kbtext);

        kbtab.add(jScrollPane2);
        jScrollPane2.setBounds(10, 10, 760, 510);

        parseKBBtn.setText("Parse Knowledge Base");
        parseKBBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                parseKBBtnActionPerformed(evt);
            }
        });

        kbtab.add(parseKBBtn);
        parseKBBtn.setBounds(557, 530, 210, 23);

        buttonGroup1.add(jrbPOSL);
        jrbPOSL.setText("POSL");
        jrbPOSL.setToolTipText("Select POSL syntax for Knowledge Base Input");
        kbtab.add(jrbPOSL);
        jrbPOSL.setBounds(110, 530, 80, 23);

        buttonGroup1.add(jrbRML);
        jrbRML.setText("RuleML 0.88+");
        jrbRML.setToolTipText(
                "Select RuleML 0.88 (with rest tags) as the knowledge base input format");
        kbtab.add(jrbRML);
        jrbRML.setBounds(190, 530, 140, 23);
        
        buttonGroup1.add(jrbRML91);
        jrbRML91.setText("RIF RuleML 0.91");
        jrbRML91.setToolTipText(
                "Select RuleML 0.91 as the knowledge base input format");
        kbtab.add(jrbRML91);
        jrbRML91.setBounds(330, 530, 200, 23);        
        

        jLabel2.setText("Input Format:");
        kbtab.add(jLabel2);
        jLabel2.setBounds(10, 530, 100, 20);

        jTabbedPane1.addTab("Knowledge Base", kbtab);

        qtab.setLayout(null);

        jLabel3.setText("Query:");
        qtab.add(jLabel3);
        jLabel3.setBounds(10, 10, 60, 60);

        jLabel4.setText("Solution:");
        qtab.add(jLabel4);
        jLabel4.setBounds(20, 110, 190, 15);

        jScrollPane3.setViewportView(solTree);

        qtab.add(jScrollPane3);
        jScrollPane3.setBounds(22, 130, 395, 420);

        queryBtn.setText("Issue Query");
        queryBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                queryBtnActionPerformed(evt);
            }
        });

        qtab.add(queryBtn);
        queryBtn.setBounds(480, 80, 140, 23);

        nextBtn.setText("Next Solution");
        nextBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextBtnActionPerformed(evt);
            }
        });

        qtab.add(nextBtn);
        nextBtn.setBounds(630, 80, 140, 23);

        jLabel5.setText("Variable Bindings:");
        qtab.add(jLabel5);
        jLabel5.setBounds(430, 110, 190, 15);

        varBindTbl.setModel(new javax.swing.table.DefaultTableModel(new Object[][] {},
                new String[] {"Variable", "Binding"}));
        jScrollPane4.setViewportView(varBindTbl);

        qtab.add(jScrollPane4);
        jScrollPane4.setBounds(430, 130, 340, 420);

        querytext.setLineWrap(true);
        querytext.setWrapStyleWord(true);
        jScrollPane5.setViewportView(querytext);

        qtab.add(jScrollPane5);
        jScrollPane5.setBounds(60, 10, 710, 60);

        jTabbedPane1.addTab("Query", qtab);

        getContentPane().add(jTabbedPane1);
        jTabbedPane1.setBounds(5, 5, 790, 590);

        showDbgBtn.setText("Show Debug Console");
        showDbgBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showDbgBtnActionPerformed(evt);
            }
        });

        getContentPane().add(showDbgBtn);
        showDbgBtn.setBounds(600, 610, 190, 23);
        showDbgBtn.getAccessibleContext().setAccessibleName("Console");

        pack();

        dtcr = new DefaultTreeCellRenderer();
        dtcr.setClosedIcon(null);
        dtcr.setOpenIcon(null);
        dtcr.setLeafIcon(null);
        this.solTree.setRootVisible(true);
        this.solTree.setCellRenderer(dtcr);

        javax.swing.tree.DefaultMutableTreeNode root = new
                DefaultMutableTreeNode("No Solutions");
        javax.swing.tree.DefaultTreeModel dtm = new DefaultTreeModel(root);

        this.solTree.setModel(dtm);
        this.solTree.setCellRenderer(dtcr);
        this.solTree.updateUI();

        this.jrbPOSL.setSelected(true);

        this.setBounds(0, 0, 808, 700);
        this.setResizable(false);

        dbgcon = new DebugConsole();

    }
    
    /**
     * This method is used to find the next solution tree to a query if there is
     * more than one solution.  This is done by calling the
     * next() method of the Backward Reasoner object.  It also sets the
     * variable bindings and displays the new solution tree.
     */
    private void nextBtnActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
        long t1 = new GregorianCalendar().getTimeInMillis();
        BackwardReasoner.GoalList gl = (BackwardReasoner.GoalList) solit.next();
        System.out.println(gl.toString());
        Hashtable varbind = gl.varBindings;
        javax.swing.tree.DefaultMutableTreeNode root = br.toTree();
        javax.swing.tree.DefaultTreeModel dtm = new DefaultTreeModel(root);

        //logger.debug("Getting next solution: ");

        this.solTree.setModel(dtm);
        this.solTree.setCellRenderer(dtcr);
        this.solTree.updateUI();

        int i = 0;
        Object[][] rowdata = new Object[varbind.size()][2];
        Enumeration e = varbind.keys();
        while (e.hasMoreElements()) {
            Object k = e.nextElement();
            Object val = varbind.get(k);
            String ks = (String) k;
            rowdata[i][0] = ks;
            rowdata[i][1] = val;
            i++;
        }
        String[] colnames = new String[] {"Variable", "Binding"};

        this.varBindTbl.setModel(new javax.swing.table.DefaultTableModel(
                rowdata, colnames));
        this.varBindTbl.updateUI();

        if (!solit.hasNext()) {
            this.nextBtn.setEnabled(false);
        }
        long t2 = new GregorianCalendar().getTimeInMillis();
        
        long time = (t2-t1);
        
        System.out.println("next solution time: "+time);
    }
    
	/**
     * This method is used to run the engine. First it has to parse the Query.
     * Then it uses the Query it just parsed to call the
     * iterativeDepthFirstSolutionIterator(Query) method of the BackwardReasoner 
     * object, this should only be done after loading type 
     * information (using an RDFSParser) and parsing (using POSLParser or RuleMLParser) and loading the knowledge
     * base using the loadClauses(Iterator clauses) method of the
     * BackwardReasoner object.
     */
    private void queryBtnActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
            long t1 = new GregorianCalendar().getTimeInMillis();
        String qstr = this.querytext.getText().trim();
        this.nextBtn.setEnabled(true);
        POSLParser pp = new POSLParser();
        DefiniteClause dc = null;
        try {
            dc = pp.parseQueryString(qstr);
        } catch (Exception ex) {
            this.logger.error(ex.getMessage(), ex);
            JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                          JOptionPane.ERROR_MESSAGE);
        }

        br = new BackwardReasoner(br.clauses, br.oids);

        //logger.debug("Finding Solutions for query: " + dc.toPOSLString());

        solit = br.iterativeDepthFirstSolutionIterator(dc);
        if (!solit.hasNext()) {
            javax.swing.tree.DefaultMutableTreeNode root = new
                    DefaultMutableTreeNode("No Solutions");
            javax.swing.tree.DefaultTreeModel dtm = new DefaultTreeModel(root);

            this.solTree.setModel(dtm);
            this.solTree.setCellRenderer(dtcr);
            this.solTree.updateUI();

            this.nextBtn.setEnabled(false);

			System.out.println(this.solTree.toString());

            varBindTbl.setModel(new javax.swing.table.DefaultTableModel(
                    new Object[][] { {null, null}
            }, new String[] {"Variable", "Binding"}));
            varBindTbl.updateUI();

        } else {
            BackwardReasoner.GoalList gl = (BackwardReasoner.GoalList) solit.
                                           next();
            System.out.println(gl.toString());
            Hashtable varbind = gl.varBindings;
            javax.swing.tree.DefaultMutableTreeNode root = br.toTree();
            root.setAllowsChildren(true);

            javax.swing.tree.DefaultTreeModel dtm = new DefaultTreeModel(root);

            this.solTree.setModel(dtm);
            this.solTree.setCellRenderer(dtcr);
            this.solTree.updateUI();
            int i = 0;
            Object[][] rowdata = new Object[varbind.size()][2];
            Enumeration e = varbind.keys();
            while (e.hasMoreElements()) {
                Object k = e.nextElement();
                Object val = varbind.get(k);
                String ks = (String) k;
                rowdata[i][0] = ks;
                rowdata[i][1] = val;
                i++;
            }
            String[] colnames = new String[] {"Variable", "Binding"};

            this.varBindTbl.setModel(new javax.swing.table.DefaultTableModel(
                    rowdata, colnames));
            this.varBindTbl.updateUI();

        }

        if (!solit.hasNext()) {
            this.nextBtn.setEnabled(false);
        }
long t2 = new GregorianCalendar().getTimeInMillis();
        
        long time = (t2-t1);
        
        System.out.println("total time: "+time);
    }
    
    /**
     * This method implements a knowledge base parsing routine.
     *
     * The first step is to reset the symbol table (call the static reset()
     * method of the SymbolTable class) and create a new BackwardReasoner
     * object.
     *
     * Then the knowledge base and the format of the knowledge base are
     * retrieved from the user interface; once this is done an appropriate
     * parser is created and the knowledge base is parse (using the
     * parseDefiniteClauses(String) method of the POSLParser class or the
     * parseRuleMLString(int FORMAT, String) method of the RuleMLParser class).
     *
     * Once the knowledge base is parsed an iterator over the parsed clauses is
     * created using the iterator() method of the RuleMLParser or POSLParser
     * class; this Iterator is then passed to the loadClauses(Iterator) method
     * of the BackwardReasoner object.
     */
     
    private void parseKBBtnActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
        //logger.debug("Parsing Knowledge Base");
        String kbstr = this.kbtext.getText();
        if (kbstr.trim().equals("")) {
            return;
        }
        SymbolTable.reset();
        this.nextBtn.setEnabled(false);
        br = new BackwardReasoner();

        if (this.jrbPOSL.isSelected()) {
            POSLParser pp = new POSLParser();
            try {
                pp.parseDefiniteClauses(kbstr);
            } catch (Exception ex) {
                this.logger.error(ex.getMessage(), ex);
                JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                              JOptionPane.ERROR_MESSAGE);
            }

            br.loadClauses(pp.iterator());
        } else if (this.jrbRML.isSelected()) {
        	
        	currentParser = RuleMLParser.RULEML88;
        	
            RuleMLParser rmp = new RuleMLParser();
            try {
                rmp.parseRuleMLString(RuleMLParser.RULEML88, kbstr);
            } catch (Exception ex) {
                this.logger.error(ex.getMessage(), ex);
                JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                              JOptionPane.ERROR_MESSAGE);
            }

            br.loadClauses(rmp.iterator());
        } else if(this.jrbRML91.isSelected()){
        	
        	currentParser = RuleMLParser.RULEML91;
        	
            RuleMLParser rmp = new RuleMLParser();
            try {
                rmp.parseRuleMLString(RuleMLParser.RULEML91, kbstr);
            } catch (Exception ex) {
                this.logger.error(ex.getMessage(), ex);
                JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                              JOptionPane.ERROR_MESSAGE);
            }

            br.loadClauses(rmp.iterator());        	
        }
    }

	/**
	 * This method shows the Debug Console.
	 */
    private void showDbgBtnActionPerformed(java.awt.event.ActionEvent evt) {
        this.dbgcon.setVisible(true);
        this.dbgcon.toFront();
    }
    
    /**
     * This method is used to load type information into the term typing
     * system.
     *
     * The first thing that is done is that the type input is retrieved from
     * the user interface, then the type system is reset. Once this is done
     * the static parseRDFSString(String) method of the RDFSParser class is
     * called to parse and load the type information.
     *
     * Since any previously parsed clauses that used types are no longer valid
     * (the types system was reset), the knowledge base is reset by calling
     * the parseKBBtnActionPerformed(ActionEvent) method of the GUI.
     */
    private void parseTypeBtnActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
        Types.reset();
        String typestr = this.typedeftext.getText();
        //logger.debug("Parsing Datatypes.");
        try {
            RDFSParser.parseRDFSString(typestr);
        } catch (Exception ex) {
            this.logger.error(ex.getMessage(), ex);
            JOptionPane.showMessageDialog(this, ex.getMessage(), "Error",
                                          JOptionPane.ERROR_MESSAGE);
        }

        //logger.debug("Datatypes updated - must reparse clauses.");
        parseKBBtnActionPerformed(evt);

    }

    /**
     * This method is called when the TopDownGUI is ran.
     *
     * @param args the command line arguments
     */
    public static void main(String args[]) {

        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    javax.swing.UIManager.setLookAndFeel(
                            javax.swing.UIManager.
                            getCrossPlatformLookAndFeelClassName());
                } catch (Exception e) {}

                BasicConfigurator.configure();
                Logger root = Logger.getRootLogger();
                root.setLevel(Level.DEBUG);
                TopDownGUI frame = new TopDownGUI();
                TextPaneAppender tpa = new TextPaneAppender(new PatternLayout(
                        "%-5p %d [%t]:  %m%n"), "Debug");
                tpa.setTextPane(frame.dbgcon.getTextPane());

                root.addAppender(tpa);
                Enumeration e = root.getAllAppenders();
                while (e.hasMoreElements()) {
                    System.out.println(e.nextElement());
                }

                jdrew.oo.Config.PRINTGENOIDS = false;

                frame.setVisible(true);
            }
        });
    }
    
    /**
     * This method prompts the user to select a file and then,
     * places its contents in the selected text area(knowledge base, Query, Types).
     */
    public static void openFile(){
        
         JFrame f1 = new JFrame();
        
         Object[] possibleValues = {"KnowledgeBase", "Types", "Query"};
         Object selectedValue = JOptionPane.showInputDialog(null,

            "Select one", "Type of File",

            JOptionPane.INFORMATION_MESSAGE, null,

            possibleValues, possibleValues[0]);
            
    if(selectedValue != null){
    
    
    System.out.println(selectedValue);

        Frame parent = new Frame();
        
        FileDialog fd = new FileDialog(parent, "Please choose a file:",
                   FileDialog.LOAD);
        fd.show();

        String selectedItem = fd.getFile();        
        String fileName = fd.getDirectory() + fd.getFile();
        
                try {

                        FileReader inFile = new FileReader(fileName);
                        BufferedReader in = new BufferedReader(inFile);
                        String read ="";
                        String contents="";
                        
                        while((read = in.readLine()) != null)
                        {
                                contents = contents + read + '\n';
                        }
                        in.close();

                                if(selectedValue.equals("KnowledgeBase")){
                                kbtext.setText(contents);
                                       
                                }
                                if(selectedValue.equals("Types")){
                                typedeftext.setText(contents);
                                        
                                }  
                                if(selectedValue.equals("Query")){  
                                querytext.setText(contents);                            
                                }
                                
                } catch (Exception e) {
                        System.out.println(e.toString());
                }              
        }//selected value != null
  }//openFile

    // Variables declaration - do not modify
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JRadioButton jrbPOSL;
    private javax.swing.JRadioButton jrbRML;
    private javax.swing.JRadioButton jrbRML91;
    private javax.swing.JPanel kbtab;
    private static javax.swing.JTextArea kbtext;
    private javax.swing.JButton nextBtn;
    private javax.swing.JButton parseKBBtn;
    private javax.swing.JButton parseTypeBtn;
    private javax.swing.JPanel qtab;
    private javax.swing.JButton queryBtn;
    private static javax.swing.JTextArea querytext;
    private javax.swing.JButton showDbgBtn;
    private javax.swing.JTree solTree;
    private javax.swing.JPanel tdtab;
    private static javax.swing.JTextArea typedeftext;
    private javax.swing.JTable varBindTbl;
    private DefaultTreeCellRenderer dtcr;
    private DebugConsole dbgcon;
    // End of variables declaration

}

 /**
  * This class implements a ExitActionTD which is used by the Menu bar in the
  * TopDownGUI.
  *
  * <p>Title: OO jDREW</p>
  *
  * <p>Description: Reasoning Engine for the Semantic Web - Supporting OO RuleML
  * 0.88</p>
  *
  * <p>Copyright: Copyright (c) 2005</p>
  *
  * @author Ben Craig
  * @version 0.89
  */

        class ExitActionTD extends AbstractAction
        {
                /**
                 *This is the contructor for a ExitAction.
                 *It calls the contructor for a AbstractAction.
                 *@param String name - the name for the action
                 */
                
                ExitActionTD(String name)
                {
                        super(name);
                }

                /**
                 *This method is called when a ExitAction is performed
                 *When an exitAction is performed it will exit the program.
                 *@param event - the event that occured
                 */

                public void actionPerformed(ActionEvent event)
                {
                        System.exit(0);
                }
        }//ExitAction
 
 /**
  * This class implements a OpenActionTD which is used by the Menu bar in the
  * TopDownGUI.
  *
  * <p>Title: OO jDREW</p>
  *
  * <p>Description: Reasoning Engine for the Semantic Web - Supporting OO RuleML
  * 0.88</p>
  *
  * <p>Copyright: Copyright (c) 2005</p>
  *
  * @author Ben Craig
  * @version 0.89
  */      
        class OpenActionTD extends AbstractAction
        {
                /**
                 * This is the contructor for a OpenAction.
                 * It calls the contructor for a AbstractAction.
                 * @param String name - the name for the action
                 */
                
                OpenActionTD(String name)
                {
                        super(name);
                }

                /**
                 * This method is called when a OpenAction is performed
                 * When an openAction is performed it will prompt the user
                 * to select a file and then will place the contents in the
                 * Knowledge base text area.
                 * @param event - the event that occured
                 */

                public void actionPerformed(ActionEvent event)
                {
                        TopDownGUI.openFile();
                }
        }//Open Action